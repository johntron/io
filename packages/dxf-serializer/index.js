const {isCAG, isCSG} = require('@jscad/csg')

const mimeType = 'application/dxf'

/**
 * Notes:
 * 1) TBD support binary output
 * 2) CAG conversion to:
 *      POLYLINE
 *      LWPOLYLINE
 * 3) CSG conversion to:
 *      3DFACE
 *      POLYLINE (polyface mesh)
 * 4) Path conversion to:
 *      LWPOLYLINE
 */
const serialize = function (objects, options) {
  const defaults = {
    cagTo: 'lwpolyline',
    csgTo: '3dface',
    pathTo: 'lwpolyline',
    statusCallback: null
  }
  options = Object.assign({}, defaults, options)

  let dxfContent = `999
DXF generated by OpenJsCad
  0
${dxfHeaders(options)}
${dxfTables(options)}
${dxfBlocks(options)}
${dxfEntities(objects,options)}
EOF
`
  return [dxfContent]
}

const dxfEntities = function (objects, options) {
  objects = toArray(objects)
  let entityContents = objects.map(function(object, i) {
    if (isCAG(object)) {
      let paths = object.getOutlinePaths()
      return PathsToDxf(paths, options)
    }
  })
  let content = `SECTION
  2
ENTITIES
  0
`
  entityContents.forEach(function(c) {
    content += c
  })
  content += `ENDSEC
  0`
  return content
}

const dxfHeaders = function (options) {
  let content = `SECTION
  2
HEADER
  0
ENDSEC
  0`
  return content
}

const dxfTables = function (options) {
  let content = `SECTION
  2
TABLES
  0
TABLE
  2
LTYPE
  70
1
  0
LTYPE
  2
CONTINUOUS
  3
Solid Line
  72
65
  73
0
  40
0.0
  0
ENDTAB
  0
TABLE
  2
LAYER
  70
1
  0
LAYER
  2
OpenJsCad
  62
7
  6
continuous
  0
ENDTAB
  0
TABLE
  2
STYLE
  70
0
  0
ENDTAB
  0
TABLE
  2
VIEW
  70
0
  0
ENDTAB
  0
ENDSEC
  0`
  return content
}

const dxfBlocks = function (options) {
  let content = `SECTION
  2
BLOCKS
  0
ENDSEC
  0`
  return content
}

const PathsToDxf = function (paths, options) {
  options.statusCallback && options.statusCallback({progress: 0})
  let str = ''
  paths.map(function (path, i) {
    var numpointsClosed = path.points.length + (path.closed ? 1 : 0)
    str += 'LWPOLYLINE\n  8\nOpenJsCad\n  90\n' + numpointsClosed + '\n  70\n' + (path.closed ? 1 : 0) + '\n'
    for (var pointindex = 0; pointindex < numpointsClosed; pointindex++) {
      var pointindexwrapped = pointindex
      if (pointindexwrapped >= path.points.length) pointindexwrapped -= path.points.length
      var point = path.points[pointindexwrapped]
      str += ' 10\n' + point.x + '\n 20\n' + point.y + '\n 30\n0.0\n'
    }
    options.statusCallback && options.statusCallback({progress: 100 * i / paths.length})
  })
  if (str.length > 0) {
    str += '  0\n'
  }
  options.statusCallback && options.statusCallback({progress: 100})
  return [str]
}

function toArray (data) {
  if (!data) return []
  if (data.constructor !== Array) return [data]
  return data
}

module.exports = {
  serialize,
  mimeType
}
